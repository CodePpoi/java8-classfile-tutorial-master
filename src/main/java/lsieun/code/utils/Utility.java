package lsieun.code.utils;

import lsieun.cst.TypeConst;

/**
 * Utility functions that do not really belong to any class in particular.
 */
public class Utility {

    /**
     * How many chars have been consumed
     * during parsing in signatureToString().
     * Read by methodSignatureToString().
     * Set by side effect,but only internally.
     */
    private static ThreadLocal<Integer> consumed_chars = new ThreadLocal<Integer>() {
        @Override
        protected Integer initialValue() {
            return Integer.valueOf(0);
        }
    };

    private static int unwrap(final ThreadLocal<Integer> tl) {
        return tl.get().intValue();
    }


    private static void wrap(final ThreadLocal<Integer> tl, final int value) {
        tl.set(Integer.valueOf(value));
    }

    /**
     * Return type of signature as a byte value as defined in <em>Constants</em>
     *
     * @param signature in format described above
     * @return type of signature
     * @see TypeConst
     */
    public static byte typeOfSignature(final String signature) {
        try {
            switch (signature.charAt(0)) {
                case 'Z':
                    return TypeConst.T_BOOLEAN;
                case 'C':
                    return TypeConst.T_CHAR;
                case 'F':
                    return TypeConst.T_FLOAT;
                case 'D':
                    return TypeConst.T_DOUBLE;
                case 'B':
                    return TypeConst.T_BYTE;
                case 'S':
                    return TypeConst.T_SHORT;
                case 'I':
                    return TypeConst.T_INT;
                case 'J':
                    return TypeConst.T_LONG;
                case 'L':
                    return TypeConst.T_OBJECT;
                case '[':
                    return TypeConst.T_ARRAY;
                case 'V':
                    return TypeConst.T_VOID;
                default:
                    throw new RuntimeException("Invalid d_method signature: " + signature);
            }
        } catch (final StringIndexOutOfBoundsException e) {
            throw new RuntimeException("Invalid d_method signature: " + signature, e);
        }
    }

    /**
     * The c_field signature represents the value of an argument to a function or
     * the value of a variable. It is a series of bytes generated by the
     * following grammar:
     *
     * <PRE>
     * &lt;field_signature&gt; ::= &lt;field_type&gt;
     * &lt;field_type&gt;      ::= &lt;base_type&gt;|&lt;object_type&gt;|&lt;array_type&gt;
     * &lt;base_type&gt;       ::= B|C|D|F|I|J|S|Z
     * &lt;object_type&gt;     ::= L&lt;fullclassname&gt;;
     * &lt;array_type&gt;      ::= [&lt;field_type&gt;
     * <p>
     * The meaning of the base types is as follows:
     * B byte signed byte
     * C char character
     * D double double precision IEEE float
     * F float single precision IEEE float
     * I int integer
     * J long long integer
     * L&lt;fullclassname&gt;; ... an object of the given class
     * S short signed short
     * Z boolean true or false
     * [&lt;c_field sig&gt; ... array
     * </PRE>
     * <p>
     * This d_method converts this string into a Java type declaration such as
     * `String[]' and throws a `RuntimeException' when the parsed type is
     * invalid.
     *
     * @param signature Class signature
     * @param chopit    Flag that determines whether chopping is executed or not
     * @return Java type declaration
     */
    public static String signatureToString(final String signature, final boolean chopit) {
        //corrected concurrent private static c_field acess
        wrap(consumed_chars, 1); // This is the default, read just one char like `B'
        try {
            switch (signature.charAt(0)) {
                case 'S':
                    return "short";
                case 'Z':
                    return "boolean";
                case 'B':
                    return "byte";
                case 'C':
                    return "char";
                case 'D':
                    return "double";
                case 'F':
                    return "float";
                case 'I':
                    return "int";
                case 'J':
                    return "long";
                case 'V':
                    return "void";
                case 'L': { // Full class name
                    // should this be a while loop? can there be more than
                    // one generic clause?  (markro)
                    int fromIndex = signature.indexOf('<'); // generic type?
                    if (fromIndex < 0) {
                        fromIndex = 0;
                    } else {
                        fromIndex = signature.indexOf('>', fromIndex);
                        if (fromIndex < 0) {
                            throw new RuntimeException("Invalid signature: " + signature);
                        }
                    }
                    final int index = signature.indexOf(';', fromIndex); // Look for closing `;'
                    if (index < 0) {
                        throw new RuntimeException("Invalid signature: " + signature);
                    }

                    // check to see if there are any TypeArguments
                    final int bracketIndex = signature.substring(0, index).indexOf('<');
                    if (bracketIndex < 0) {
                        // just a class identifier
                        wrap(consumed_chars, index + 1); // "Lblabla;" `L' and `;' are removed
                        return compactClassName(signature.substring(1, index), chopit);
                    }
                    // but make sure we are not looking past the end of the current item
                    fromIndex = signature.indexOf(';');
                    if (fromIndex < 0) {
                        throw new RuntimeException("Invalid signature: " + signature);
                    }
                    if (fromIndex < bracketIndex) {
                        // just a class identifier
                        wrap(consumed_chars, fromIndex + 1); // "Lblabla;" `L' and `;' are removed
                        return compactClassName(signature.substring(1, fromIndex), chopit);
                    }

                    // we have TypeArguments; build up partial result
                    // as we recurse for each TypeArgument
                    final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append("<");
                    int consumed_chars = bracketIndex + 1; // Shadows global var

                    // check for wildcards
                    if (signature.charAt(consumed_chars) == '+') {
                        type.append("? extends ");
                        consumed_chars++;
                    } else if (signature.charAt(consumed_chars) == '-') {
                        type.append("? super ");
                        consumed_chars++;
                    }

                    // get the first TypeArgument
                    if (signature.charAt(consumed_chars) == '*') {
                        type.append("?");
                        consumed_chars++;
                    } else {
                        type.append(signatureToString(signature.substring(consumed_chars), chopit));
                        // update our consumed count by the number of characters the for type argument
                        consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;
                        wrap(Utility.consumed_chars, consumed_chars);
                    }

                    // are there more TypeArguments?
                    while (signature.charAt(consumed_chars) != '>') {
                        type.append(", ");
                        // check for wildcards
                        if (signature.charAt(consumed_chars) == '+') {
                            type.append("? extends ");
                            consumed_chars++;
                        } else if (signature.charAt(consumed_chars) == '-') {
                            type.append("? super ");
                            consumed_chars++;
                        }
                        if (signature.charAt(consumed_chars) == '*') {
                            type.append("?");
                            consumed_chars++;
                        } else {
                            type.append(signatureToString(signature.substring(consumed_chars), chopit));
                            // update our consumed count by the number of characters the for type argument
                            consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;
                            wrap(Utility.consumed_chars, consumed_chars);
                        }
                    }

                    // process the closing ">"
                    consumed_chars++;
                    type.append(">");

                    if (signature.charAt(consumed_chars) == '.') {
                        // we have a ClassTypeSignatureSuffix
                        type.append(".");
                        // convert SimpleClassTypeSignature to fake ClassTypeSignature
                        // and then recurse to parse it
                        type.append(signatureToString("L" + signature.substring(consumed_chars + 1), chopit));
                        // update our consumed count by the number of characters the for type argument
                        // note that this count includes the "L" we added, but that is ok
                        // as it accounts for the "." we didn't consume
                        consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;
                        wrap(Utility.consumed_chars, consumed_chars);
                        return type.toString();
                    }
                    if (signature.charAt(consumed_chars) != ';') {
                        throw new RuntimeException("Invalid signature: " + signature);
                    }
                    wrap(Utility.consumed_chars, consumed_chars + 1); // remove final ";"
                    return type.toString();
                }

                case '[': { // Array declaration
                    int n;
                    StringBuilder brackets;
                    String type;
                    int consumed_chars; // Shadows global var
                    brackets = new StringBuilder(); // Accumulate []'s
                    // Count opening brackets and look for optional size argument
                    for (n = 0; signature.charAt(n) == '['; n++) {
                        brackets.append("[]");
                    }
                    consumed_chars = n; // Remember value
                    // The rest of the string denotes a `<field_type>'
                    type = signatureToString(signature.substring(n), chopit);
                    //corrected concurrent private static c_field acess
                    //Utility.consumed_chars += consumed_chars; is replaced by:
                    final int _temp = unwrap(Utility.consumed_chars) + consumed_chars;
                    wrap(Utility.consumed_chars, _temp);
                    return type + brackets.toString();
                }
                default:
                    throw new RuntimeException("Invalid signature: `" + signature + "'");
            }
        } catch (final StringIndexOutOfBoundsException e) { // Should never occur
            throw new RuntimeException("Invalid signature: " + signature, e);
        }
    }

    /**
     * Shorten long class names, <em>java/lang/String</em> becomes
     * <em>java.lang.String</em>,
     * e.g.. If <em>chopit</em> is <em>true</em> the prefix <em>java.lang</em>
     * is also removed.
     *
     * @param str    The long class name
     * @param chopit Flag that determines whether chopping is executed or not
     * @return Compacted class name
     */
    public static String compactClassName(final String str, final boolean chopit) {
        return compactClassName(str, "java.lang.", chopit);
    }

    /**
     * Shorten long class name <em>str</em>, i.e., chop off the <em>prefix</em>,
     * if the
     * class name starts with this string and the flag <em>chopit</em> is true.
     * Slashes <em>/</em> are converted to dots <em>.</em>.
     *
     * @param str    The long class name
     * @param prefix The prefix the get rid off
     * @param chopit Flag that determines whether chopping is executed or not
     * @return Compacted class name
     */
    public static String compactClassName(String str, final String prefix, final boolean chopit) {
        final int len = prefix.length();
        str = str.replace('/', '.'); // Is `/' on all systems, even DOS
        if (chopit) {
            // If string starts with `prefix' and contains no further dots
            if (str.startsWith(prefix) && (str.substring(len).indexOf('.') == -1)) {
                str = str.substring(len);
            }
        }
        return str;
    }
}
